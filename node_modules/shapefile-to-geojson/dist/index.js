"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Parser_instances, _Parser_shp, _Parser_dbf, _Parser_configuration, _Parser_features, _Parser_propertiesArray, _Parser_parseShp, _Parser_parseDbf, _Parser_geoJSON;
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseFiles = exports.parseFolder = void 0;
const fs_1 = require("fs");
const path = require("path");
/**
 * Parses a folder path containing a `shp` & `dbf` file pair into a GeoJSON object.
 * @param folder The path to the folder containing the `shp` & `dbf` file.
 * @param configuration The configuration settings to use.
 * @returns A promise containing the GeoJSON object.
 */
const parseFolder = async (folder, configuration) => {
    const files = await fs_1.promises.readdir(folder);
    const shpFiles = files.filter((file) => file.endsWith(".shp"));
    const dbfFiles = files.filter((file) => file.endsWith(".dbf"));
    if (shpFiles.length > 1) {
        throw new Error("Multiple shapefiles found.");
    }
    if (dbfFiles.length > 1) {
        throw new Error("Multiple dbf files found.");
    }
    if (shpFiles.length === 0) {
        throw new Error("No shapefiles found.");
    }
    if (dbfFiles.length === 0) {
        throw new Error("No dbf files found.");
    }
    return (0, exports.parseFiles)(path.join(folder, shpFiles[0]), path.join(folder, dbfFiles[0]), configuration);
};
exports.parseFolder = parseFolder;
class Parser {
    constructor(shp, dbf, configuration) {
        _Parser_instances.add(this);
        _Parser_shp.set(this, void 0);
        _Parser_dbf.set(this, void 0);
        _Parser_configuration.set(this, void 0);
        _Parser_features.set(this, []);
        _Parser_propertiesArray.set(this, []);
        __classPrivateFieldSet(this, _Parser_shp, shp, "f");
        __classPrivateFieldSet(this, _Parser_dbf, dbf, "f");
        __classPrivateFieldSet(this, _Parser_configuration, configuration, "f");
    }
    parse() {
        __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_parseShp).call(this);
        __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_parseDbf).call(this);
        return __classPrivateFieldGet(this, _Parser_instances, "m", _Parser_geoJSON).call(this);
    }
}
_Parser_shp = new WeakMap(), _Parser_dbf = new WeakMap(), _Parser_configuration = new WeakMap(), _Parser_features = new WeakMap(), _Parser_propertiesArray = new WeakMap(), _Parser_instances = new WeakSet(), _Parser_parseShp = function _Parser_parseShp() {
    const dataView = new DataView(new Uint8Array(__classPrivateFieldGet(this, _Parser_shp, "f")).buffer);
    let idx = 0;
    const fileCode = dataView.getInt32(idx, false);
    const wordLength = dataView.getInt32(idx += 6 * 4, false);
    const byteLength = wordLength * 2;
    const version = dataView.getInt32(idx += 4, true);
    const shapeType = dataView.getInt32(idx += 4, true);
    const minX = dataView.getFloat64(idx += 4, true);
    const minY = dataView.getFloat64(idx + 8, true);
    const maxX = dataView.getFloat64(idx + 16, true);
    const maxY = dataView.getFloat64(idx + 24, true);
    const minZ = dataView.getFloat64(idx + 32, true);
    const maxZ = dataView.getFloat64(idx + 40, true);
    const minM = dataView.getFloat64(idx + 48, true);
    const maxM = dataView.getFloat64(idx + 56, true);
    idx += 8 * 8;
    const features = [];
    while (idx < byteLength) {
        const feature = {};
        const number = dataView.getInt32(idx, false);
        const length = dataView.getInt32(idx += 4, false);
        try {
            const type = dataView.getInt32(idx += 4, true);
            let idxFeature = idx + 4;
            const byteLen = length * 2;
            switch (type) {
                case 1:
                case 11:
                case 21:
                    feature.type = "Point";
                    feature.coordinates = [
                        dataView.getFloat64(idxFeature, true),
                        dataView.getFloat64(idxFeature + 8, true)
                    ];
                    break;
                case 3:
                case 13:
                case 23:
                case 5:
                case 15:
                case 25:
                    if (type === 3 || type === 13 || type === 23) {
                        feature.type = "MultiLineString";
                    }
                    else if (type === 5 || type === 15 || type === 25) {
                        feature.type = "Polygon";
                    }
                    const numberOfParts = dataView.getInt32(idxFeature + 32, true);
                    const nbpoints = dataView.getInt32(idxFeature + 36, true);
                    idxFeature += 40;
                    const nbpartsPoint = new Array(numberOfParts).fill(0).map(() => {
                        const result = dataView.getInt32(idxFeature, true);
                        idxFeature += 4;
                        return result;
                    });
                    feature.coordinates = new Array(numberOfParts).fill(0).map((_, i) => {
                        const idstart = nbpartsPoint[i];
                        const idend = (i < numberOfParts - 1 ? nbpartsPoint[i + 1] : nbpoints) - 1;
                        const part = [];
                        for (let j = idstart; j <= idend; j++) {
                            part.push([
                                dataView.getFloat64(idxFeature, true),
                                dataView.getFloat64(idxFeature + 8, true)
                            ]);
                            idxFeature += 16;
                        }
                        return part;
                    });
                    break;
                case 8:
                case 18:
                case 28:
                    feature.type = "MultiPoint";
                    const numberOfPoints = dataView.getInt32(idxFeature + 32, true);
                    idxFeature += 36;
                    feature.coordinates = new Array(numberOfPoints).fill(0).map(() => {
                        const result = [
                            dataView.getFloat64(idxFeature, true),
                            dataView.getFloat64(idxFeature + 8, true)
                        ];
                        idxFeature += 16;
                        return result;
                    });
                    break;
            }
        }
        catch (e) { }
        idx += length * 2;
        features.push(feature);
    }
    __classPrivateFieldSet(this, _Parser_features, features, "f");
}, _Parser_parseDbf = function _Parser_parseDbf() {
    var _a;
    const dataView = new DataView(new Uint8Array(__classPrivateFieldGet(this, _Parser_dbf, "f")).buffer);
    let idx = 4;
    const numberOfRecords = dataView.getInt32(idx, true);
    idx += 28;
    let end = false;
    const fields = [];
    try {
        while (true) {
            let field = {};
            let nameArray = [];
            for (let i = 0; i < 10; i++) {
                let letter = dataView.getUint8(idx);
                if (letter != 0) {
                    nameArray.push(String.fromCharCode(letter));
                }
                idx += 1;
            }
            field.name = nameArray.join("");
            idx += 1;
            field.type = String.fromCharCode(dataView.getUint8(idx));
            idx += 5;
            field.fieldLength = dataView.getUint8(idx);
            idx += 16;
            fields.push(field);
            if (dataView.getUint8(idx) == 0x0D) {
                break;
            }
        }
    }
    catch (err) {
        end = true;
    }
    idx += 1;
    let propertiesArray = [];
    for (let i = 0; i < numberOfRecords; i++) {
        let properties = {};
        if (!end) {
            try {
                idx += 1;
                for (let j = 0; j < fields.length; j++) {
                    let str = "";
                    // if (this.#configuration?.iconvLiteDecodeFn && this.#configuration?.inputEncoding) {
                    // 	let buffer = [];
                    // 	for (let h = 0; h < fields[j].fieldLength; h++) {
                    // 		buffer.push(dataView.getUint8(idx));
                    // 		idx += 1;
                    // 	}
                    // 	str = this.#configuration?.iconvLiteDecodeFn(buffer, this.#configuration?.inputEncoding)
                    // } else {
                    let charString = [];
                    for (let h = 0; h < fields[j].fieldLength; h++) {
                        charString.push(String.fromCharCode(dataView.getUint8(idx)));
                        idx += 1;
                    }
                    str = charString.join("");
                    // }
                    if (((_a = __classPrivateFieldGet(this, _Parser_configuration, "f")) === null || _a === void 0 ? void 0 : _a.trim) !== false) {
                        str = str.trim();
                    }
                    const number = parseFloat(str);
                    if (isNaN(number)) {
                        properties[fields[j].name] = str;
                    }
                    else {
                        properties[fields[j].name] = number;
                    }
                }
            }
            catch (err) {
                end = true;
            }
        }
        propertiesArray.push(properties);
    }
    __classPrivateFieldSet(this, _Parser_propertiesArray, propertiesArray, "f");
}, _Parser_geoJSON = function _Parser_geoJSON() {
    const geojson = {
        "type": "FeatureCollection",
        "features": []
    };
    for (let i = 0; i < Math.min(__classPrivateFieldGet(this, _Parser_features, "f").length, __classPrivateFieldGet(this, _Parser_propertiesArray, "f").length); i++) {
        geojson.features.push({
            "type": "Feature",
            "geometry": __classPrivateFieldGet(this, _Parser_features, "f")[i],
            "properties": __classPrivateFieldGet(this, _Parser_propertiesArray, "f")[i]
        });
    }
    return geojson;
};
/**
 * Parses `shp` & `dbf` files into a GeoJSON object.
 * @param shpFile The path to the `shp` file.
 * @param dbfFile The path to the `dbf` file.
 * @param configuration The configuration settings to use.
 * @returns A promise containing the GeoJSON object.
 */
const parseFiles = async (shpFile, dbfFile, configuration) => {
    if (typeof shpFile === "string") {
        shpFile = await fs_1.promises.readFile(shpFile);
    }
    if (typeof dbfFile === "string") {
        dbfFile = await fs_1.promises.readFile(dbfFile);
    }
    return new Parser(shpFile, dbfFile, configuration).parse();
};
exports.parseFiles = parseFiles;
//# sourceMappingURL=index.js.map